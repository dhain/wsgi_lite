Standard WSGI Apps
------------------

We'll use the ``test()`` function to simulate a WSGI server::

    >>> from test_wsgi_lite import test

    >>> def hello_world(environ, start_response):
    ...     """Standard WSGI version of hello_world"""
    ...     start_response('200 OK', [('Content-type','text/plain')])
    ...     return ['Hello world!']

    >>> test(hello_world)
    Status: 200 OK
    Content-type: text/plain
    Content-Length: 12
    <BLANKLINE>
    Hello world!

As you can see, it runs regular WSGI apps normally.  Now let's try some
``@lite`` and ``lighten()`` apps::

    >>> from wsgi_lite import lite, lighten


``lighten()``
-------------

Lightening a standard WSGI app leaves it still able to do normal WSGI, via
a pass-through::

    >>> test(lighten(hello_world))
    Status: 200 OK
    Content-type: text/plain
    Content-Length: 12
    <BLANKLINE>
    Hello world!

Wrapped functions are roughly the same as their original in terms of
attributes, docstrings, etc. (as long as either functools or DecoratorTools
are available)::

    >>> help(hello_world)
    Help on function hello_world:
    <BLANKLINE>
    hello_world(environ, start_response)
        Standard WSGI version of hello_world
    <BLANKLINE>

But the second argument is always optional::

    >>> help(lighten(hello_world))
    Help on function hello_world...:
    <BLANKLINE>
    hello_world(environ, start_response=None)
        Standard WSGI version of hello_world
    <BLANKLINE>

So that the lightened function can support being called with the single-
argument protocol, as well as standard WSGI::

    >>> to_close = []
    >>> empty_env = {'wsgi_lite.register_close': to_close.append}

    >>> lighten(hello_world)(empty_env)
    ('200 OK', [('Content-type', 'text/plain')], ['Hello world!'])


Wrapping is idempotent, so lightening an already-lightened function returns
the same function::

    >>> hw = lighten(hello_world)
    >>> lighten(hw) is hw
    True


``@lite``
---------

A "lite" app only takes an environ, and returns a status/headers/body triple::

    >>> def hello_lite(environ):
    ...     """'lite' version of hello_world"""
    ...     return (
    ...         '200 OK', [('Content-type','text/plain')],
    ...         ['Hello world!']
    ...     )

But if wrapped with ``@lite``, is still usable in a standard WSGI server::

    >>> test(lite(hello_lite))
    Status: 200 OK
    Content-type: text/plain
    Content-Length: 12
    <BLANKLINE>
    Hello world!

Because in this case, the wrapper *adds* an optional start_response parameter::

    >>> help(lite(hello_lite))
    Help on function hello_lite...:
    <BLANKLINE>
    hello_lite(environ, start_response=None)
        'lite' version of hello_world
    <BLANKLINE>

Instead of making an existing parameter optional::

    >>> help(hello_lite)
    Help on function hello_lite:
    <BLANKLINE>
    hello_lite(environ)
        'lite' version of hello_world
    <BLANKLINE>

So that calling it with just one argument returns a status/headers/body tuple::

    >>> lite(hello_lite)(empty_env)
    ('200 OK', [('Content-type', 'text/plain')], ['Hello world!'])

just as was the case for the underlying function::

    >>> hello_lite(empty_env)
    ('200 OK', [('Content-type', 'text/plain')], ['Hello world!'])


Even so, as with ``lighten()``, ``@lite`` is idempotent::

    >>> hw = lite(hello_lite)
    >>> lite(hw) is hw
    True

Also, ``lighten()`` and ``@lite`` are idempotent to each other, as well as
themselves::

    >>> hw = lite(hello_lite)
    >>> lighten(hw) is hw
    True

    >>> hw = lighten(hello_world)
    >>> lite(hw) is hw
    True


To-Test
-------

lighten():
  * Empty items yielded before start_response should still work
  * (App whose body is a generator, too)
  * write() tests (greenlets required for most):
    * Raise error if greenlets disabled and write() called
    * Single write() and start_response() in main request, empty iterator
    * Multiple write() in main request, non-empty iterator w/close()
  * register_closer extension available in app's environ

Closing in general:
  * registered closables are closed by standard WSGI close() at outermost
    "lite"-supporting decorator/middleware
  * @with_closing:
    * changing child environ doesn't affect parent
    * only iterators w/close methods are registered
    * registration is innermost-first

Middleware and WSGI compliance:
  * "latinator" re-implementation
    * full wsgiref.validate on both sides
    * wrap both lite and lightened
    * call with WSGI and lite protocols
  * write() from body iterator raises error
  * Multi-set of headers w/out exc_info raises error
  * Non-empty pre-start yield raises error

Response Wrapping:
 * close() only happens once
 * len() passes through to wrapped iterator
 * pushbacks
 * custom extra close

