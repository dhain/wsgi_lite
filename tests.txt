Standard WSGI Apps
------------------

We'll use the ``test()`` function to simulate a WSGI server::

    >>> from test_wsgi_lite import test

    >>> def hello_world(environ, start_response):
    ...     """Standard WSGI version of hello_world"""
    ...     start_response('200 OK', [('Content-type','text/plain')])
    ...     return ['Hello world!']

    >>> test(hello_world)
    Status: 200 OK
    Content-type: text/plain
    Content-Length: 12
    <BLANKLINE>
    Hello world!

As you can see, it runs regular WSGI apps normally.  Now let's try some
``@lite`` and ``lighten()`` apps::

    >>> from wsgi_lite import lite, lighten


``lighten()``
-------------

Lightening a standard WSGI app leaves it still able to do normal WSGI, via
a pass-through::

    >>> test(lighten(hello_world))
    Status: 200 OK
    Content-type: text/plain
    Content-Length: 12
    <BLANKLINE>
    Hello world!

Wrapped functions are roughly the same as their original in terms of
attributes, docstrings, etc. (as long as either functools or DecoratorTools
are available)::

    >>> help(hello_world)
    Help on function hello_world:
    <BLANKLINE>
    hello_world(environ, start_response)
        Standard WSGI version of hello_world
    <BLANKLINE>

But the second argument is always optional::

    >>> help(lighten(hello_world))
    Help on function hello_world...:
    <BLANKLINE>
    hello_world(environ, start_response=None)
        Standard WSGI version of hello_world
    <BLANKLINE>

So that the lightened function can support being called with the single-
argument protocol, as well as standard WSGI::

    >>> to_close = []
    >>> empty_env = {'wsgi_lite.register_close': to_close.append}

    >>> lighten(hello_world)(empty_env)
    ('200 OK', [('Content-type', 'text/plain')], ['Hello world!'])


Wrapping is idempotent, so lightening an already-lightened function returns
the same function::

    >>> hw = lighten(hello_world)
    >>> lighten(hw) is hw
    True


``@lite``
---------

A "lite" app only takes an environ, and returns a status/headers/body triple::

    >>> def hello_lite(environ):
    ...     """'lite' version of hello_world"""
    ...     return (
    ...         '200 OK', [('Content-type','text/plain')],
    ...         ['Hello world!']
    ...     )

But if wrapped with ``@lite``, is still usable in a standard WSGI server::

    >>> test(lite(hello_lite))
    Status: 200 OK
    Content-type: text/plain
    Content-Length: 12
    <BLANKLINE>
    Hello world!

Because in this case, the wrapper *adds* an optional start_response parameter::

    >>> help(lite(hello_lite))
    Help on function hello_lite...:
    <BLANKLINE>
    hello_lite(environ, start_response=None)
        'lite' version of hello_world
    <BLANKLINE>

Instead of making an existing parameter optional::

    >>> help(hello_lite)
    Help on function hello_lite:
    <BLANKLINE>
    hello_lite(environ)
        'lite' version of hello_world
    <BLANKLINE>

So that calling it with just one argument returns a status/headers/body tuple::

    >>> lite(hello_lite)(empty_env)
    ('200 OK', [('Content-type', 'text/plain')], ['Hello world!'])

just as was the case for the underlying function::

    >>> hello_lite(empty_env)
    ('200 OK', [('Content-type', 'text/plain')], ['Hello world!'])


Even so, as with ``lighten()``, ``@lite`` is idempotent::

    >>> hw = lite(hello_lite)
    >>> lite(hw) is hw
    True

Also, ``lighten()`` and ``@lite`` are idempotent to each other, as well as
themselves::

    >>> hw = lite(hello_lite)
    >>> lighten(hw) is hw
    True

    >>> hw = lighten(hello_world)
    >>> lite(hw) is hw
    True


Middleware
----------

Now let's try using some WSGI Lite middleware built with ``@lite`` and
``lighten()``.  We'll use the ``latinator`` example from our README file::

    >>> from test_wsgi_lite import latinator

First, wrapping plain old WSGI::

    >>> test(latinator(hello_world))
    Status: 200 OK
    Content-type: text/plain
    <BLANKLINE>
    elloHay orldway!

Then, wrapping a ``@lite`` application (called via WSGI or WSGI Lite)::

    >>> test(latinator(lite(hello_lite)))
    Status: 200 OK
    Content-type: text/plain
    <BLANKLINE>
    elloHay orldway!

    >>> s, h, b = latinator(lite(hello_lite))(empty_env)
    >>> s, h, [''.join(b)]
    ('200 OK', [('Content-type', 'text/plain')], ['elloHay orldway!'])

And a ``lighten()``-ed one::

    >>> test(latinator(lighten(hello_world)))
    Status: 200 OK
    Content-type: text/plain
    <BLANKLINE>
    elloHay orldway!

    >>> s, h, b = latinator(lighten(hello_world))(empty_env)
    >>> s, h, [''.join(b)]
    ('200 OK', [('Content-type', 'text/plain')], ['elloHay orldway!'])


As you can see, when you write middleware using ``@lite`` to wrap the
middleware, and ``lighten()`` to wrap the called app, all of the hard bits
of WSGI response processing get abstracted away.

Just to be sure, though, let's check our WSGI compliance out a bit::

    >>> from wsgiref.validate import validator
    >>> vtest = lambda *args, **kw: test(QUERY_STRING='', *args, **kw)

    >>> vtest(validator(latinator(validator(hello_world))))
    Status: 200 OK
    Content-type: text/plain
    <BLANKLINE>
    elloHay orldway!

    >>> vtest(validator(latinator(validator(lighten(hello_world)))))
    Status: 200 OK
    Content-type: text/plain
    <BLANKLINE>
    elloHay orldway!

    >>> vtest(validator(latinator(validator(lite(hello_lite)))))
    Status: 200 OK
    Content-type: text/plain
    <BLANKLINE>
    elloHay orldway!


To-Test
-------

``@bind``:
  * names/docstrings
  * stacking
  * keyword arg/func-as-name checking
  * rebind checking
  * argument name checking
  * after-lite checking
  * default args processing
  * callables
  * tuples
  * unsupported rule errors
    * changing child environ doesn't affect parent
  
lighten():
  * Empty items yielded before start_response should still work
  * (App whose body is a generator, too)
  * write() tests (greenlets required for most):
    * Raise error if greenlets disabled and write() called
    * Multiple write() in main request, non-empty iterator w/close()
  * register_closer extension available in app's environ

Closing in general:
  * registered closables are closed by standard WSGI close() at outermost
    "lite"-supporting decorator/middleware
  * registered item is returned
  * @with_closing binds it
  * Correct closing order

Middleware and WSGI compliance:
  * Multi-set of headers w/out exc_info raises error
  * Non-empty pre-start yield raises error

Response Wrapping:
 * close() only happens once
 * len() passes through to wrapped iterator
 * pushbacks
 * custom extra close - correct order

